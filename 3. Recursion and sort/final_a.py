'''
ID решения: 52328278


--- ПРИНЦИП РАБОТЫ ---
    Алгоритм работает по немного доработанному принципу бинарного поиска. После разбития рассматриваемого
    диапазона на 2 равные части для определения поддиапазона в котором дальше будет осуществляться поиск
    искомый элемент не просто сравнивается с элементом в середине рассматриваемого диапазона, а для каждого
    из поддиапазонов рассматривается 2 возможных варианта:
    1) в поддиапазоне отсутствует "разрыв", и тогда искомый элемент находится в диапазоне
    [первый элемент диапазона, последний элемент диапазона]
    2) В поддиапазоне присутсвует "разрыв", и тогда искомый элемент должен быть больше первого элемента
    поддиапазона ИЛИ меньше последнего элемента поддиапазона
    Функция продолжает итеративно искать элемент пока:
    1) При очередном разбитии диапазона на 2 части не окажется, что элемент по которому происходит
    разбитие является искомым элементом
    2) При очередном разбитии не окажется что искомый элемент не попадает ни в один из двух образующихся
    диапазонов.
    В первом случае возвращается искомый элемент, во втором случае возвращается -1
    Разбитие диапазона происходит с помощью двух указателей (start и end), которые указывают на начало
    и конец рассматриваемого диапазона. При каждом разбитии один из диапазонов сдвигается навстречу второму.
    Алгоритм работает итеративно

--- ВРЕМЕННАЯ СЛОЖНОСТЬ ---
    Это небольшая доработка простого бинарного поиска, поэтому временная сложность у него такая же -  O(log n)

--- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ ---
    Пространственная сложность алгоритма составляет О(1), так как поиск элемента осуществляется
    без создания дополнительных структур данных
'''

def broken_search(nums, target) -> int:
    end = len(nums)
    start = 0
    while end - start > 0:
        mid = (end + start) // 2
        if nums[mid] == target:
            return mid
        elif nums[start] <= target <= nums[mid-1] or \
                (nums[start] > nums[mid-1] and (target >= nums[start] or target <= nums[mid-1])):
            end = mid
        elif nums[mid] <= target <= nums[end-1] or \
                (nums[mid] > nums[end-1] and (target > nums[mid] or target < nums[end-1])):
            start = mid
        else:
            return -1


def test():
    target = int(input())
    arr = [int(x) for x in input().split()]
    assert broken_search(arr, target) == 6


if __name__ == '__main__':
    test()