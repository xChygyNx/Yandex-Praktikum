"""
ID решения: 55182472

---ПРИНЦИП РАБОТЫ---

    Считываются строки для которых будет считаться расстояние Левенштейна. Затем создается
    двумерная динамика размером (n + 1) * (m + 1), где n - длина первой строки, m -  длина
    второй строки. Первая строка и первый столбец динамики
    заполняются возрастающей последовательностью от 0 до len(str1|str2). Динамика содержит
    количество операций вставки/удалений/замен символов которые надо сделать для превращения
    одной строки в другую, причем в dp[i][j] содержится количество операций, требуемое
    для превращения префикса первой строки длиной в i символов в префикс второй строки
    длиной j символов. Таким образом в первой строке и первом столбце динамики будет
    длина префикса одной из строк, так как любую последовательность длины х можно
    превратить в пустую последовательность только за х операций удаления символов.
    Перемещение по столбцу/строке динамики обозначает увеличения префикса одной из
    строк на 1 символ. При увеличении одной из строк на 1 символ количество необходимых
    операций так же увелричивается на 1. При смещении по диагонали на 1 в нижний правый
    угол динамики префиксы обеих строк увеличиваются на 1 символ, и тут 2 варианта:
    если символы которые добавляются в префиксы разные, то количество операций
    возрастает на 1 (замена), если совпадает, то количество операций не меняется.
    Так идем построчно по динамике и в каждой строке заполняем ячейки слева направо -
    сохраняем в ней минимальное из значений: dp[i-1][j] + 1 или dp[i][j-1] или
    dp[i-1][j-1] + (0|1). Так заполняем всю динамику, ответ будет лежать в нижней
    правой ячейке.

---ВРЕМЕННАЯ СЛОЖНОСТЬ---
    Построение загодовки динамики занимает O((n+1)*(m+1)) = O(nm) времени, где n -
    длина первой строки, а m - длина второй. Ее заполнение занимает еще O(nm).
    Итоговая временная сложность составляет O(nm)

---ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ---
    Для алгоритма требуется двумерная динамика размером (n+1)*(m+1), где n -
    длина первой строки, а m - длина второй. Итоговая пространственная сложность
    составляет O(nm)
"""


from typing import List


def op_cost(symbol1: str, symbol2: str) -> int:
    return 0 if symbol1 == symbol2 else 1


def fill_dynamic(matrix: List[List[int]], str1: str, str2: str) -> None:
    for i in range(1, len(str1) + 1):
        for j in range(1, len(str2) + 1):
            matrix[i][j] = min(matrix[i-1][j] + 1, matrix[i][j-1] + 1, matrix[i-1][j-1] + op_cost(str1[i-1], str2[j-1]))


if __name__ == '__main__':
    str1 = input()
    str2 = input()
    matrix = [[0 if j != 0 else i for j in range(len(str2) + 1)] for i in range(len(str1) + 1)]
    matrix[0] = [x for x in range(len(str2) + 1)]
    fill_dynamic(matrix, str1, str2)
    print(matrix[-1][-1])