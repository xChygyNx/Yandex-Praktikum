"""
ID решения: 55492427

---ПРИНЦИП РАБОТЫ---

    Считываются строки для которых будет считаться расстояние Левенштейна. Затем создается
    динамика c числами в диапазоне от 0 до m, где m -  длина второй строки. Динамика содержит
    количество операций вставки/удалений/замен символов которые надо сделать для превращения
    одной строки в другую, причем в dp[i] содержится количество операций, требуемое
    для превращения префикса второй строки длиной в i символов в префикс первой строки
    длиной j символов, где j - это номер итерации. Динамика будет заполнятся во вложенном
    цикле. Каждая итерация внешнего цикла обозначает увеличения префикса первой строки на
    1 символ, каждая итерация вложенного цикла - увеличение префикса второй строки на
    1 символ. Мы каждую итерацию вешнего цикла динамику из предыдущей итерации копируем в
    отдельную переменную (перед первым циклом копируем динамику, которая просто диапазон
    чисел от 0 до m), и создаем отдельный список, который представляет динамику для префикса
    первой строки длиной i. При увеличении одной из строк на 1 символ количество необходимых
    операций так же увелричивается на 1. При увеличении префиксов обеих строк на 1 символ
    возникает 2 варианта: если символы которые добавляются в префиксы разные, то количество операций
    возрастает на 1 (замена), если совпадает, то количество операций не меняется.
    Так каждую итерацию в список который обозначает динамику для префикса первой строки длиной
    i добавляем минимальное из значений: prev[j] + 1 или curr[-1] + 1 или
    prev[j-1] + (0|1). Так заполняем всю динамику, ответ будет лежать в последней ячейке
    списка curr получившейся в последней итерации.

---ВРЕМЕННАЯ СЛОЖНОСТЬ---
    Построение загодовки динамики занимает O(n+1) = O(n) времени, где n -
    длина второй строки. В последующем придется создавать новую динамику для
    нового префикса первой строки m раз, и заполнять ее n значениями, где m - длина первой
    строки. Итоговая временная сложность составляет O(nm)

---ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ---
    Для алгоритма требуется 2 списка длиной n, где n - длина второй строки. Итоговая
    пространственная сложность алгоритма составляет O(n)
"""


from typing import List
from copy import copy


def op_cost(symbol1: str, symbol2: str) -> int:
    return 0 if symbol1 == symbol2 else 1


def fill_dynamic(dp: List[int], str1: str, str2: str) -> List[int]:
    curr = dp
    for i in range(1, len(str1) + 1):
        prev = copy(curr)
        curr = [i]
        for j in range(1, len(str2) + 1):
            curr.append(min(prev[j] + 1, curr[-1] + 1, prev[j-1] + op_cost(str1[i-1], str2[j-1])))
    return curr


if __name__ == '__main__':
    str1 = input()
    str2 = input()
    dp = [x for x in range(len(str2) + 1)]
    dp = fill_dynamic(dp, str1, str2)
    print(dp[-1])